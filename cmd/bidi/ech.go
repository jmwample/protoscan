package main

import (
	"encoding/hex"
	"fmt"
	"log"
	"math/rand"
	"net"
	"os"
	"path/filepath"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
	"github.com/google/gopacket/pcapgo"
)

const echProbeTypeName = "ech"

type echProber struct {
	sender *tcpSender

	dkt *KeyTable

	outDir string
}

func (p *echProber) registerFlags() {
}

func (p *echProber) sendProbe(ip net.IP, name string, verbose bool) error {

	out, err := p.buildPayload(name)
	if err != nil {
		return fmt.Errorf("failed to build tls payload: %s", err)
	}

	sport, _ := p.dkt.get(name)

	addr := net.JoinHostPort(ip.String(), "443")
	seqAck, sport, err := p.sender.sendTCP(addr, sport.(int), name, out, verbose)
	if err == nil && verbose {
		log.Printf("Sent :%d -> %s %s %s\n", sport, addr, name, seqAck)
	}

	return err
}

// buildPayload builds a tls payload
//
// As demonstrated by the GeneratePayloads perf benchmark lots (~30%) of tls
// payload build time is spent on hex.Decode which is avoidable. However, for
// now generating payload is really fast anyways and hex is a convenient format
// in which to interact with the payload. It might make sense to do hex.Decode
// calls as some sort of init if speed matters in the future. Or move to using
// slice init with bytes. But for now it doesn't matter.
func (p *echProber) buildPayload(name string) ([]byte, error) {
	return buildECH1_3(name, true)
}

func (p *echProber) handlePcap(iface string) {
	f, _ := os.Create(filepath.Join(p.outDir, "tls.pcap"))
	w := pcapgo.NewWriter(f)
	w.WriteFileHeader(1600, layers.LinkTypeEthernet)
	defer f.Close()

	if handle, err := pcap.OpenLive(iface, 1600, true, pcap.BlockForever); err != nil {
		panic(err)
	} else if err := handle.SetBPFFilter("icmp or tcp src port 443"); err != nil { // optional
		panic(err)
	} else {
		defer handle.Close()

		packetSource := gopacket.NewPacketSource(handle, handle.LinkType())
		for packet := range packetSource.Packets() {
			// p.handlePacket(packet)
			w.WritePacket(packet.Metadata().CaptureInfo, packet.Data())
		}
	}
}

func (p *echProber) handlePacket(packet gopacket.Packet) {

	var ipAddr net.IP
	ipLayer := packet.Layer(layers.LayerTypeIPv4)
	if ipLayer == nil {
		ip6Layer := packet.Layer(layers.LayerTypeIPv6)
		if ip6Layer == nil {
			return
		}
		ip6, _ := ip6Layer.(*layers.IPv6)
		ipAddr = ip6.SrcIP
	} else {
		ip4, _ := ipLayer.(*layers.IPv4)
		ipAddr = ip4.SrcIP
	}

	tcpLayer := packet.Layer(layers.LayerTypeTCP)
	if tcpLayer == nil {
		return
	}
	tcp, _ := tcpLayer.(*layers.TCP)

	// log.Printf("RESULT %s %s, %s %d answers: %s\n",
	// 	ipAddr, questions[0].Name, dns.ResponseCode, len(answers), hex.EncodeToString(tcp.Payload))

	if tcp.NextLayerType() != 0 {
		log.Printf("RESULT TLS %s %v", ipAddr, tcp.RST)
	} else {
		log.Printf("RESULT TLS")
	}
}

func buildECH1_2(name string) ([]byte, error) {
	// Record headder
	var rh = "160301"

	// dynamic - bytes of handshake to follow
	var packetLen = fmt.Sprintf("%04x", len(name)+0xc8)

	// Handshake header and client version
	var hh = "01" + fmt.Sprintf("%06x", len(name)+0xc4) + "0303"

	// dynamic - client Rand (32 generated bytes)
	buf := make([]byte, 32)
	n, err := rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var clientRandom = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
	var clientRandom = hex.EncodeToString(buf)

	// dynamic - session ID (33 bytes 32 generated)
	n, err = rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var sessionID = "20e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"
	var sessionID = "20" + hex.EncodeToString(buf)

	// Ciphersuites & Compression methods
	var csAndCM = "001cc02bc02fcca9cca8c02cc030c00ac009c013c014009c009d002f00350100"

	// dynamic - Extensions lenggth (00a3)
	var extensionsLen = fmt.Sprintf("%04x", len(name)+0x5f)

	var extSNIID = "0000"
	// dynamic - Extension lenggth (0018)
	var extSNIDataLen = fmt.Sprintf("%04x", len(name)+5)
	// dynamic - Extension lenggth (0016)
	var extSNIEntryLen = fmt.Sprintf("%04x", len(name)+3)
	var extSNIEntryType = "00"
	// dynamic - Extension lenggth (0013)
	var hostnameLen = fmt.Sprintf("%04x", len(name))
	var hostname = hex.EncodeToString([]byte(name))

	var otherExtensions = "000b000403000102000a00160014001d0017001e0019001801000101010201030104002300000016000000170000000d001e001c040305030603080708080809080a080b080408050806040105010601002d00020101"

	fulldata := rh + packetLen + hh + clientRandom + sessionID + csAndCM + extensionsLen + extSNIID + extSNIDataLen + extSNIEntryLen + extSNIEntryType + hostnameLen + hostname + otherExtensions
	return hex.DecodeString(fulldata)
}

func buildECH1_3(name string, esni bool) ([]byte, error) {
	// var fulldata = "16030100f8010000f40303000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff000813021303130100ff010000a30000001800160000136578616d706c652e756c666865696d2e6e6574000b000403000102000a00160014001d0017001e0019001801000101010201030104002300000016000000170000000d001e001c040305030603080708080809080a080b080408050806040105010601002b0003020304002d00020101003300260024001d0020358072d6365880d1aeea329adf9121383851ed21a28e3b75e965d0d2cd166254"

	var extLen = len(name) + 4 + 0x8c

	var extSNIID = "0000"
	// dynamic - Extension lenggth (0018)
	var extSNIDataLen = fmt.Sprintf("%04x", len(name)+5)
	// dynamic - Extension lenggth (0016)
	var extSNIEntryLen = fmt.Sprintf("%04x", len(name)+3)
	var extSNIEntryType = "00"
	// dynamic - Extension lenggth (0013)
	var hostnameLen = fmt.Sprintf("%04x", len(name))
	var hostname = hex.EncodeToString([]byte(name))
	var extSNI = extSNIID + extSNIDataLen + extSNIEntryLen + extSNIEntryType + hostnameLen + hostname

	var extESNI = ""
	if esni {
		// dynamic(random) - Encrypted Client Hello extension
		var extESNIHeader = "ffce016e1301001d0020"
		buf := make([]byte, 32)
		n, err := rand.Read(buf)
		if err != nil || n != 32 {
			return nil, fmt.Errorf("failed rand read: %s", err)
		}
		var extESNIKeyExchange = hex.EncodeToString(buf)
		buf = make([]byte, 32)
		n, err = rand.Read(buf)
		if err != nil || n != 32 {
			return nil, fmt.Errorf("failed rand read: %s", err)
		}
		var extESNIDigest = hex.EncodeToString(buf)
		buf = make([]byte, 0x124)
		n, err = rand.Read(buf)
		if err != nil || n != 0x124 {
			return nil, fmt.Errorf("failed rand read: %s", err)
		}
		var extESNIRecord = hex.EncodeToString(buf)
		extESNI = extESNIHeader + extESNIKeyExchange + "0020" + extESNIDigest + "0124" + extESNIRecord
		extLen += len(extESNI) / 2
		fmt.Println(extLen, len(extESNI)/2)
	}

	// dynamic(random) - Client KeyShare extension public key
	buf := make([]byte, 32)
	n, err := rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	var extKeySharePubkey = hex.EncodeToString(buf)
	var extKeyShare = "003300260024001d0020" + extKeySharePubkey

	var otherExtensions = extKeyShare + "000b000403000102000a00160014001d0017001e0019001801000101010201030104002300000016000000170000000d001e001c040305030603080708080809080a080b080408050806040105010601002b0003020304002d00020101"

	// dynamic - Extensions lenggth
	var extensionsLen = fmt.Sprintf("%04x", extLen)

	// Ciphersuites & Compression methods
	var csAndCM = "000813021303130100ff0100"

	// dynamic - session ID (33 bytes 32 generated)
	n, err = rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var sessionID = "20e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"
	var sessionID = "20" + hex.EncodeToString(buf)

	// dynamic - client Rand (32 generated bytes)
	buf = make([]byte, 32)
	n, err = rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var clientRandom = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
	var clientRandom = hex.EncodeToString(buf)

	// Handshake header and client version
	var hh = "01" + fmt.Sprintf("%06x", extLen+0x51) + "0303"

	// dynamic - bytes of handshake to follow
	var packetLen = fmt.Sprintf("%04x", extLen+0x55)

	// Record headder
	var rh = "160301"

	fulldata := rh + packetLen + hh + clientRandom + sessionID + csAndCM + extensionsLen + extSNI + extESNI + otherExtensions
	return hex.DecodeString(fulldata)
}

/*
dc57decf03911722f6a7a23629b82bd45193ae065dbdca93aa62029e6fc63032
0020
4ad65ffbaf50f3b6799139f398880755835b40081394bccf53737b752822b9f3
0124

c49e269199cb6f0d332a466df8e79cd02cc9a7755edfcef2cf7933b22ea9f1ec40c1b8dbb285fd942792710529ab47e4cfb099e2807e251f0803d55dcd4522009fb8091207330756b276f5b13b0b7a632995e92f3afc5c0a7598b94a7bb0d9a7f85600c269b9dc7bfa51d8bb19858bb64dbe24a06aa7c864adf84dd87db166c5dc049a4ad81d5db1f6f65fcd99b014b8176f80dbb968f239c6d1aec7b3b6353509fe10b0db7324bdbe09c5a64ba312f3cf1918fa6e586762cfa69c5e63acecd94e907f3da4fd1a247511e6d5ff9ad80843c73cfe5e79af80eeaf52ff832d8dfd408669d72790c9f52e79578c1a15a96201fb9c9c7c36ad35c3a06ef45e07b320f6108a95899631f23860a68ce9c4f1c510a6e63a7a174cac0f72d7939092177785503c53001c00024001
*/
