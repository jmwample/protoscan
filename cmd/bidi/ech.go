package main

// ESNI based on pcap parsable by wireshark
//
// ECH based on sftcd/openssl implementation
// (https://github.com/sftcd/openssl/blob/ECH-draft-13c/esnistuff/building-curl-openssl-with-ech.md)
// and draft RFC 13. Works for Draft 14 as well as ClientHello Extension did not
// materially change between the proposals.

import (
	"encoding/hex"
	"fmt"
	"log"
	"math/rand"
	"net"
	"os"
	"path/filepath"
	"sync"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
	"github.com/google/gopacket/pcapgo"
)

const echProbeTypeName = "ech"
const esniProbeTypeName = "esni"

type echProber struct {
	sender *tcpSender

	dkt *KeyTable

	esni bool
	ech  bool

	send1_3 bool

	outDir string
}

func (p *echProber) registerFlags() {
}

func (p *echProber) sendProbe(ip net.IP, name string, verbose bool) error {

	out, err := p.buildPayload(name)
	if err != nil {
		return fmt.Errorf("failed to build tls payload: %s", err)
	}

	sport, _ := p.dkt.get(name)

	addr := net.JoinHostPort(ip.String(), "443")
	seqAck, sport, err := p.sender.sendTCP(addr, sport.(int), name, out, verbose)
	if err == nil && verbose {
		log.Printf("Sent :%d -> %s %s %s\n", sport, addr, name, seqAck)
	}

	return err
}

// buildPayload builds a tls payload
//
// As demonstrated by the GeneratePayloads perf benchmark lots (~30%) of tls
// payload build time is spent on hex.Decode which is avoidable. However, for
// now generating payload is really fast anyways and hex is a convenient format
// in which to interact with the payload. It might make sense to do hex.Decode
// calls as some sort of init if speed matters in the future. Or move to using
// slice init with bytes. But for now it doesn't matter.
func (p *echProber) buildPayload(name string) ([]byte, error) {
	if p.send1_3 {
		return buildECH1_3(name, p.ech, p.esni)
	}

	if p.esni || p.ech {
		return nil, fmt.Errorf("tls 1.2 not supported for ech/esni")
	}
	return buildECH1_2(name)
}

func (p *echProber) handlePcap(iface string, exit chan struct{}, wg *sync.WaitGroup) {
	f, _ := os.Create(filepath.Join(p.outDir, "tls.pcap"))
	w := pcapgo.NewWriter(f)
	w.WriteFileHeader(1600, layers.LinkTypeEthernet)
	defer f.Close()

	if handle, err := pcap.OpenLive(iface, 1600, true, pcap.BlockForever); err != nil {
		panic(err)
	} else if err := handle.SetBPFFilter("icmp or icmp6 or tcp src port 443"); err != nil { // optional
		panic(err)
	} else {
		defer handle.Close()

		packetSource := gopacket.NewPacketSource(handle, handle.LinkType())
		for packet := range packetSource.Packets() {
			// p.handlePacket(packet)
			w.WritePacket(packet.Metadata().CaptureInfo, packet.Data())
		}
	}
}

func (p *echProber) handlePacket(packet gopacket.Packet) {

	var ipAddr net.IP
	ipLayer := packet.Layer(layers.LayerTypeIPv4)
	if ipLayer == nil {
		ip6Layer := packet.Layer(layers.LayerTypeIPv6)
		if ip6Layer == nil {
			return
		}
		ip6, _ := ip6Layer.(*layers.IPv6)
		ipAddr = ip6.SrcIP
	} else {
		ip4, _ := ipLayer.(*layers.IPv4)
		ipAddr = ip4.SrcIP
	}

	tcpLayer := packet.Layer(layers.LayerTypeTCP)
	if tcpLayer == nil {
		return
	}
	tcp, _ := tcpLayer.(*layers.TCP)

	// log.Printf("RESULT %s %s, %s %d answers: %s\n",
	// 	ipAddr, questions[0].Name, dns.ResponseCode, len(answers), hex.EncodeToString(tcp.Payload))

	if tcp.NextLayerType() != 0 {
		log.Printf("RESULT TLS %s %v", ipAddr, tcp.RST)
	} else {
		log.Printf("RESULT TLS")
	}
}

func buildECH1_2(name string) ([]byte, error) {
	// Record headder
	var rh = "160301"

	// dynamic - bytes of handshake to follow
	var packetLen = fmt.Sprintf("%04x", len(name)+0xc8)

	// Handshake header and client version
	var hh = "01" + fmt.Sprintf("%06x", len(name)+0xc4) + "0303"

	// dynamic - client Rand (32 generated bytes)
	buf := make([]byte, 32)
	n, err := rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var clientRandom = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
	var clientRandom = hex.EncodeToString(buf)

	// dynamic - session ID (33 bytes 32 generated)
	n, err = rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var sessionID = "20e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"
	var sessionID = "20" + hex.EncodeToString(buf)

	// Ciphersuites & Compression methods
	var csAndCM = "001cc02bc02fcca9cca8c02cc030c00ac009c013c014009c009d002f00350100"

	// dynamic - Extensions lenggth (00a3)
	var extensionsLen = fmt.Sprintf("%04x", len(name)+0x5f)

	var extSNIID = "0000"
	// dynamic - Extension lenggth (0018)
	var extSNIDataLen = fmt.Sprintf("%04x", len(name)+5)
	// dynamic - Extension lenggth (0016)
	var extSNIEntryLen = fmt.Sprintf("%04x", len(name)+3)
	var extSNIEntryType = "00"
	// dynamic - Extension lenggth (0013)
	var hostnameLen = fmt.Sprintf("%04x", len(name))
	var hostname = hex.EncodeToString([]byte(name))

	var otherExtensions = "000b000403000102000a00160014001d0017001e0019001801000101010201030104002300000016000000170000000d001e001c040305030603080708080809080a080b080408050806040105010601002d00020101"

	fulldata := rh + packetLen + hh + clientRandom + sessionID + csAndCM + extensionsLen + extSNIID + extSNIDataLen + extSNIEntryLen + extSNIEntryType + hostnameLen + hostname + otherExtensions
	return hex.DecodeString(fulldata)
}

func buildECH1_3(name string, ech, esni bool) ([]byte, error) {
	// var fulldata = "16030100f8010000f40303000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff000813021303130100ff010000a30000001800160000136578616d706c652e756c666865696d2e6e6574000b000403000102000a00160014001d0017001e0019001801000101010201030104002300000016000000170000000d001e001c040305030603080708080809080a080b080408050806040105010601002b0003020304002d00020101003300260024001d0020358072d6365880d1aeea329adf9121383851ed21a28e3b75e965d0d2cd166254"

	var extLen = len(name) + 4 + 0x8c

	var extSNIID = "0000"
	// dynamic - Extension lenggth (0018)
	var extSNIDataLen = fmt.Sprintf("%04x", len(name)+5)
	// dynamic - Extension lenggth (0016)
	var extSNIEntryLen = fmt.Sprintf("%04x", len(name)+3)
	var extSNIEntryType = "00"
	// dynamic - Extension lenggth (0013)
	var hostnameLen = fmt.Sprintf("%04x", len(name))
	var hostname = hex.EncodeToString([]byte(name))
	var extSNI = extSNIID + extSNIDataLen + extSNIEntryLen + extSNIEntryType + hostnameLen + hostname

	var extESNI = ""
	var extECH = ""
	if esni {
		recordLen := rand.Intn(320-100+1) + 100

		// dynamic(random) - Encrypted Client Hello extension
		var extESNIHeader = "ffce" + fmt.Sprintf("%04x", recordLen+0x4a) + "1301001d0020"
		buf := make([]byte, 32)
		n, err := rand.Read(buf)
		if err != nil || n != 32 {
			return nil, fmt.Errorf("failed rand read: %s", err)
		}
		var extESNIKeyExchange = hex.EncodeToString(buf)
		buf = make([]byte, 32)
		n, err = rand.Read(buf)
		if err != nil || n != 32 {
			return nil, fmt.Errorf("failed rand read: %s", err)
		}
		var extESNIDigest = hex.EncodeToString(buf)
		buf = make([]byte, recordLen)
		n, err = rand.Read(buf)
		if err != nil || n != recordLen {
			return nil, fmt.Errorf("failed rand read: %s", err)
		}
		var extESNIRecord = hex.EncodeToString(buf)
		extESNI = extESNIHeader + extESNIKeyExchange + "0020" + extESNIDigest + fmt.Sprintf("%04x", recordLen) + extESNIRecord
		extLen += len(extESNI) / 2
	} else if ech {
		// extension id fe0d draft 13 and 14 ( fe0c draft 12/ fe0e non-existent draft 15? )
		// len (2B)
		// type (1B?)
		// kdf (2B?)
		// aead (2B?)
		// config id (1B)
		// enc len (2B)
		// enc (20B)
		// payload_len (2B)
		// payload
		payloadLen := rand.Intn(320-100+1) + 100

		// dynamic(random) - Encrypted Client Hello extension
		var extECHHeader = "fe0d" + fmt.Sprintf("%04x", payloadLen+42) + "0000010001"
		buf := make([]byte, 1)
		n, err := rand.Read(buf)
		if err != nil || n != 1 {
			return nil, fmt.Errorf("failed rand read: %s", err)
		}
		var extECHConfigID = hex.EncodeToString(buf)
		buf = make([]byte, 32)
		n, err = rand.Read(buf)
		if err != nil || n != 32 {
			return nil, fmt.Errorf("failed rand read: %s", err)
		}
		var extECHEnc = hex.EncodeToString(buf)

		buf = make([]byte, payloadLen)
		n, err = rand.Read(buf)
		if err != nil || n != payloadLen {
			return nil, fmt.Errorf("failed rand read: %s", err)
		}
		var extECHRecord = hex.EncodeToString(buf)
		extECH = extECHHeader + extECHConfigID + "0020" + extECHEnc + fmt.Sprintf("%04x", payloadLen) + extECHRecord
		extLen += len(extECH) / 2

		// 00
		// 0001
		// 0001
		// f5
		// 0020
		// aaa4f06190b9037c7b628b0a7b0bc27d69ef50761612db01600c57e7744eed30
		// 0110
		// fa14ecc6c65cedf4ecb108ee383be7d7325db934deb7dbf8254179e374a31908a2feceef9a8a458815e612e17e1075c0f6293a35c5f152d8ed0642632ff69c621f43e60d09a7260291537551a079a15e08ad941c75ec143602b18911e2fddb2c0135cdf3e5a91b02ad6e78a5eddc32b13772c10aa6b101a47e353cf4187071ee4a1874d052f6459cc826e1dafb2028fb7ce22746a295d7ecc405ad20cc3c918c5a3a93a4c3c2846d9327e22cbe617c4d7512214c259ab1f5a6af136376cbc577ff991eb12c362a877edcf28673c2480c4db04630baa4ed2ed17c170a3c46714bef8e6bc20dfe593ddf4e7d71bda993f05859fa1bbb91936668d662b89e1627e980bf2b575f37d3f22e06bf7b953c36ea
	}

	// dynamic(random) - Client KeyShare extension public key
	buf := make([]byte, 32)
	n, err := rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	var extKeySharePubkey = hex.EncodeToString(buf)
	var extKeyShare = "003300260024001d0020" + extKeySharePubkey

	var otherExtensions = extKeyShare + "000b000403000102000a00160014001d0017001e0019001801000101010201030104002300000016000000170000000d001e001c040305030603080708080809080a080b080408050806040105010601002b0003020304002d00020101"

	// dynamic - Extensions lenggth
	var extensionsLen = fmt.Sprintf("%04x", extLen)

	// Ciphersuites & Compression methods
	var csAndCM = "000813021303130100ff0100"

	// dynamic - session ID (33 bytes 32 generated)
	n, err = rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var sessionID = "20e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"
	var sessionID = "20" + hex.EncodeToString(buf)

	// dynamic - client Rand (32 generated bytes)
	buf = make([]byte, 32)
	n, err = rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var clientRandom = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
	var clientRandom = hex.EncodeToString(buf)

	// Handshake header and client version
	var hh = "01" + fmt.Sprintf("%06x", extLen+0x51) + "0303"

	// dynamic - bytes of handshake to follow
	var packetLen = fmt.Sprintf("%04x", extLen+0x55)

	// Record headder
	var rh = "160301"

	fulldata := rh + packetLen + hh + clientRandom + sessionID + csAndCM + extensionsLen + extSNI + extESNI + extECH + otherExtensions
	return hex.DecodeString(fulldata)
}

/*
dc57decf03911722f6a7a23629b82bd45193ae065dbdca93aa62029e6fc63032
0020
4ad65ffbaf50f3b6799139f398880755835b40081394bccf53737b752822b9f3
0124

c49e269199cb6f0d332a466df8e79cd02cc9a7755edfcef2cf7933b22ea9f1ec40c1b8dbb285fd942792710529ab47e4cfb099e2807e251f0803d55dcd4522009fb8091207330756b276f5b13b0b7a632995e92f3afc5c0a7598b94a7bb0d9a7f85600c269b9dc7bfa51d8bb19858bb64dbe24a06aa7c864adf84dd87db166c5dc049a4ad81d5db1f6f65fcd99b014b8176f80dbb968f239c6d1aec7b3b6353509fe10b0db7324bdbe09c5a64ba312f3cf1918fa6e586762cfa69c5e63acecd94e907f3da4fd1a247511e6d5ff9ad80843c73cfe5e79af80eeaf52ff832d8dfd408669d72790c9f52e79578c1a15a96201fb9c9c7c36ad35c3a06ef45e07b320f6108a95899631f23860a68ce9c4f1c510a6e63a7a174cac0f72d7939092177785503c53001c00024001
*/
