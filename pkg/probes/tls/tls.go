package tls

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"log"
	"net"
	"path/filepath"
	"sync"

	"github.com/google/gopacket"

	"github.com/jmwample/protoscan/pkg/send/tcp"
	"github.com/jmwample/protoscan/pkg/shared"
	"github.com/jmwample/protoscan/pkg/track"
)

const (
	// ProbeTypeName TLS probe name
	ProbeTypeName = "tls"

	// BPFFilter provides a filter for traffic expected by in response to this probe
	BPFFilter = "tcp src port 443"
) // Prober implements the Probe interface for a UDP DNS probe.

type Prober struct {
	Sender *tcp.Sender

	DKT *track.KeyTable

	// Options passed to the sender on each send. Useful for when more than one
	// prober is using a sender and may want packets sent with different options
	SenderOptions interface{}

	OutDir      string
	CaptureICMP bool
}

// RegisterFlags adds any flags specific to this particular probe type as part
// of the Prober interface
func (p *Prober) RegisterFlags() {}

// SendProbe generates a payload and sends a probe (can be more than one packet)
// as part of the Prober interface
func (p *Prober) SendProbe(ip net.IP, name string, verbose bool) error {
	out, err := p.buildPayload(name)
	if err != nil {
		return fmt.Errorf("failed to build tls payload: %s", err)
	}

	sport, _ := p.DKT.Get(name)

	addr := net.JoinHostPort(ip.String(), "443")
	seqAck, sport, err := p.Sender.Send(addr, sport.(int), out, p.SenderOptions)
	if err == nil && verbose {
		log.Printf("Sent :%d -> %s %s %s\n", sport, addr, name, seqAck)
	}

	return err
}

// HandlePcap deals with response traffic in a way specific to this probe type
// as part of the Prober interface. Callback disabled for This capture
func (p *Prober) HandlePcap(ctx context.Context, iface string, wg *sync.WaitGroup) {
	pcapName := ProbeTypeName + ".pcap"
	pcapPath := filepath.Join(p.OutDir, pcapName)
	bpfFilter := BPFFilter

	if p.CaptureICMP {
		bpfFilter = "icmp or icmp6 or " + bpfFilter
	}
	shared.CapturePcap(ctx, iface, pcapPath, bpfFilter, nil, wg)
}

// RecvCallback is the function called by the pcap handler if we want to do unique tracking
// and feedback for the probe orchestration or output. None implemented yet.
func (p *Prober) RecvCallback(packet gopacket.Packet) {
	return
}

// buildPayload builds a tls payload
//
// As demonstrated by the GeneratePayloads perf benchmark lots (~30%) of tls
// payload build time is spent on hex.Decode which is avoidable. However, for
// now generating payload is really fast anyways and hex is a convenient format
// in which to interact with the payload. It might make sense to do hex.Decode
// calls as some sort of init if speed matters in the future. Or move to using
// slice init with bytes. But for now it doesn't matter.
func (p *Prober) buildPayload(name string) ([]byte, error) {
	return buildTLS1_2(name)
}

func buildTLS1_2(name string) ([]byte, error) {
	// Record headder
	var rh = "160301"

	// dynamic - bytes of handshake to follow
	var packetLen = fmt.Sprintf("%04x", len(name)+0xc8)

	// Handshake header and client version
	var hh = "01" + fmt.Sprintf("%06x", len(name)+0xc4) + "0303"

	// dynamic - client Rand (32 generated bytes)
	buf := make([]byte, 32)
	n, err := rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var clientRandom = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
	var clientRandom = hex.EncodeToString(buf)

	// dynamic - session ID (33 bytes 32 generated)
	n, err = rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var sessionID = "20e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"
	var sessionID = "20" + hex.EncodeToString(buf)

	// Ciphersuites & Compression methods
	var csAndCM = "001cc02bc02fcca9cca8c02cc030c00ac009c013c014009c009d002f00350100"

	// dynamic - Extensions lenggth (00a3)
	var extensionsLen = fmt.Sprintf("%04x", len(name)+0x5f)

	var extSNIID = "0000"
	// dynamic - Extension lenggth (0018)
	var extSNIDataLen = fmt.Sprintf("%04x", len(name)+5)
	// dynamic - Extension lenggth (0016)
	var extSNIEntryLen = fmt.Sprintf("%04x", len(name)+3)
	var extSNIEntryType = "00"
	// dynamic - Extension lenggth (0013)
	var hostnameLen = fmt.Sprintf("%04x", len(name))
	var hostname = hex.EncodeToString([]byte(name))

	var otherExtensions = "000b000403000102000a00160014001d0017001e0019001801000101010201030104002300000016000000170000000d001e001c040305030603080708080809080a080b080408050806040105010601002d00020101"

	fulldata := rh + packetLen + hh + clientRandom + sessionID + csAndCM + extensionsLen + extSNIID + extSNIDataLen + extSNIEntryLen + extSNIEntryType + hostnameLen + hostname + otherExtensions
	return hex.DecodeString(fulldata)
}

func buildTLS1_3(name string) ([]byte, error) {
	// var fulldata = "16030100f8010000f40303000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff000813021303130100ff010000a30000001800160000136578616d706c652e756c666865696d2e6e6574000b000403000102000a00160014001d0017001e0019001801000101010201030104002300000016000000170000000d001e001c040305030603080708080809080a080b080408050806040105010601002b0003020304002d00020101003300260024001d0020358072d6365880d1aeea329adf9121383851ed21a28e3b75e965d0d2cd166254"

	// Record headder
	var rh = "160301"

	// dynamic - bytes of handshake to follow
	var packetLen = fmt.Sprintf("%04x", len(name)+0xe5)

	// Handshake header and client version
	var hh = "01" + fmt.Sprintf("%06x", len(name)+0xe1) + "0303"

	// dynamic - client Rand (32 generated bytes)
	buf := make([]byte, 32)
	n, err := rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var clientRandom = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
	var clientRandom = hex.EncodeToString(buf)

	// dynamic - session ID (33 bytes 32 generated)
	n, err = rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	// var sessionID = "20e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"
	var sessionID = "20" + hex.EncodeToString(buf)

	// Ciphersuites & Compression methods
	var csAndCM = "000813021303130100ff0100"

	// dynamic - Extensions lenggth (00a3)
	var extensionsLen = fmt.Sprintf("%04x", len(name)+0x90)

	var extSNIID = "0000"
	// dynamic - Extension lenggth (0018)
	var extSNIDataLen = fmt.Sprintf("%04x", len(name)+5)
	// dynamic - Extension lenggth (0016)
	var extSNIEntryLen = fmt.Sprintf("%04x", len(name)+3)
	var extSNIEntryType = "00"
	// dynamic - Extension lenggth (0013)
	var hostnameLen = fmt.Sprintf("%04x", len(name))
	var hostname = hex.EncodeToString([]byte(name))

	// dynamic(random) - Client KeyShare extension public key
	buf = make([]byte, 32)
	n, err = rand.Read(buf)
	if err != nil || n != 32 {
		return nil, fmt.Errorf("failed rand read: %s", err)
	}
	var extKeySharePubkey = hex.EncodeToString(buf)
	var extKeyShare = "003300260024001d0020" + extKeySharePubkey

	var otherExtensions = extKeyShare + "000b000403000102000a00160014001d0017001e0019001801000101010201030104002300000016000000170000000d001e001c040305030603080708080809080a080b080408050806040105010601002b0003020304002d00020101"

	fulldata := rh + packetLen + hh + clientRandom + sessionID + csAndCM + extensionsLen + extSNIID + extSNIDataLen + extSNIEntryLen + extSNIEntryType + hostnameLen + hostname + otherExtensions
	return hex.DecodeString(fulldata)
}
